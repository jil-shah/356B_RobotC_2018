#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl3,  Encod_R,        sensorQuadEncoder)
#pragma config(Sensor, dgtl11, Encod_L,        sensorQuadEncoder)
#pragma config(Motor,  port1,           right_mid,     tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           right_front,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           shooter_right, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           shooter_b,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           left_back,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           right_back,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intake,        tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           shooter_left,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           left_front,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          left_mid,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The front of the robot is the intake

// VOID FOR THE RIGHT SIDE OF THE ROBOT
void driver(int speed)
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
}

// VOID FOR THE LEFT SIDE OF THE ROBOT
void drivel(int speed)
{
	motor[left_front] = speed;
	motor[left_mid] = speed;
	motor[left_back] = speed;
}

// VOID FOR THE INTAKE
void roller(int speed)
{
	motor[intake] = speed;
}

// TIME THEORY 
int R_Freq = 50;
int R_Batt = 8628;
int P_Freq = R_Freq * (R_Batt / nImmediateBatteryLevel);
// Initial values for Sensors: in 1 = 854  in 2 = 2288
// Initial values for IMEs: port 1 = 0  port 2 = 0  port 3 = 0

// TIME VOID FOR TIME THEORY
void wait(int temp)
{
	wait1Msec( P_Freq * temp);
}


void moveBase(int speed)
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
	motor[left_front] = speed;
	motor[left_mid] = speed;
	motor[left_back] = speed;
}

void brake()
{
	motor[right_front] = 50;
	motor[right_mid] = -50;
	motor[left_front] = 50;
	motor[left_mid] = -50;
}

void _chasis(int speed, int time, bool temp)
{
	moveBase(speed);
	wait(time);
	if (temp == true)
	{
		brake();
		wait1Msec(1000);
	}
}

void rightBase(int speed)
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
}
void leftBase(int speed)
{
	motor[left_front] = speed;
	motor[left_mid] = speed;
	motor[left_back] = speed;
}

void turnBase(int speed) // positve is clockwise
{
	motor[right_front] = speed;
	motor[right_mid] = speed;
	motor[right_back] = speed;
	motor[left_front] = -speed;
	motor[left_mid] = -speed;
	motor[left_back] = -speed;
}
void break_drive(){
	rightBase(0);
	leftBase(0);
}
void straight (int speed)
{
	//one of the encoder values will be negative just multiple the value by -1 at the beginning and set it to a variable to make it easier
	leftBase(speed);
	rightBase(speed);
	if (SensorValue(abs(Encod_R))>SensorValue (abs(Encod_L)))
	{
		leftBase(speed);
		rightBase(speed-2);
	}
	else if (SensorValue (abs(Encod_R))< SensorValue(abs (Encod_L)))
	{
		leftBase(speed-2);
		rightBase(speed);
	}
}

void straight_dist (int dist, int power)
{
	//Encoder ticks = (360 / circumference) * Distance to travel
	//circumference = 4* pi = 28.67 rounded up to 29 due to floating point error in robotc
	//use this formula to drive straight for a certain distance

	int tickGoal = (29*dist)/10;
	int totalTicks = 0;
	int slavePower = power -5;
	int error =0;

	int kp =5;

	SensorValue[Encod_L] =0;
	SensorValue[Encod_R] =0;

	while (abs (totalTicks ) <tickGoal )
	{
		motor[right_front] = power;
		motor[right_mid] = power;
		motor[right_back] = power;
		motor[left_front] = power;
		motor[left_mid] = power;
		motor[left_back] = power;
		error = SensorValue[Encod_L] -(-1*(SensorValue [Encod_R] ));
		slavePower += error / kp;

		SensorValue [Encod_L] =0;
		SensorValue [Encod_R] =0;

		wait1Msec (100);

		totalTicks += SensorValue[Encod_L];
	}
	leftBase(0);
	rightBase(0);
}

void slow_straight (int dist)
{
	straight_dist (dist, 20);
}

//TICKS/INCH FORMULA                                                 //TEST THIS OUT
//reading: ticks -- 627.2 ticks/revolution
//1 turn of the wheels -- 4 inch wheels == 627.2*2 ticks
//1 turn of each wheel 4*pi inches
//4*pi inches = 627.2*2 ticks
//ticks/inch = 627.2*2/(4*pi) = 99.82198

//when my error is 30
//the actual error is inches - 30

const float ticksperinch = 99.82198;
const float ticksPerTurn = 2207; // ? not sure you might want to test it first // when you doing this turn robot 360 and add bot encoder values together
const int wheel_base = 11.5; // make sure its in inches
const int wheel_dia = 360;

int fixTimerValue(float rawSeconds)
{
	int miliseconds;
	miliseconds = rawSeconds*1000;
	if(miliseconds < 250)
	{
		miliseconds = 250;
	}
	return miliseconds;
}

int inchToTicks (float inch)
{
	int ticks;
	ticks = inch*ticksperinch;
	return ticks;
}

int degreesToTicks(float degrees)
{
	int ticks;
	ticks = degrees*ticksPerTurn/360;
	return ticks;
}

/*int degreesToTicks(float degrees)
{
int ticks;
ticks = degrees*wheel_base/wheel_dia;
return ticks;
}*/

void PIDbaseControl(float target, float waitTime, float maxPower = 127)
{
	float Kp = 0.5;
	float Ki = 0.0009;
	float Kd = 0.5;
	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	const float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	float Kp_C = 0.01;
	int error_drift;
	float proportion_drift;

	bool timerBool = true;

	SensorValue[Encod_L] = 0;
	SensorValue[Encod_R] = 0;

	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{
		error = inchToTicks(target) - (SensorValue[Encod_L] + SensorValue[Encod_R]);
		proportion = Kp*error;
		if(abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw + error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;
		derivative = Kd*(error - lastError);
		lastError = error;
		if (error == 0)
		{
			derivative = 0;
		}
		finalPower = proportion + integral + derivative; //proportion+derivative+integral
		if (finalPower > maxPower)
		{
			finalPower = maxPower;
		}
		else if (finalPower < -maxPower)
		{
			finalPower = -maxPower;
		}

		error_drift = SensorValue[Encod_R] - SensorValue[Encod_L];
		proportion_drift = Kp_C * error_drift;

		leftBase(finalPower+proportion_drift);
		rightBase(finalPower-proportion_drift);
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

void PIDbaseTurn(float target, float waitTime, float maxPower = 127)
{
	float Kp = 0.75;
	float Ki = -0.0009;
	float Kd = 0.5;
	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;

	const float integralActiveZone = inchToTicks(3);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	bool timerBool = true;

	SensorValue[Encod_L] = 0;
	SensorValue[Encod_R] = 0;

	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{
		error = degreesToTicks(target) - ((SensorValue[Encod_L]) - (-1*SensorValue[Encod_R]));
		proportion = Kp*error;
		if(abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw + error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;
		derivative = Kd*(error - lastError);
		lastError = error;
		if (error == 0)
		{
			derivative = 0;
		}
		finalPower = proportion + integral + derivative; //proportion+derivative+integral
		if (finalPower > maxPower)
		{
			finalPower = maxPower;
		}
		else if (finalPower < -maxPower)
		{
			finalPower = -maxPower;
		}

		turnBase(finalPower);
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	turnBase(0);
}

void shooter(int speed)
{
	motor[shooter_left] =speed;
	motor[shooter_right] =speed;
	motor[shooter_b] = speed;
}

void forward_drive (int speed){
	rightBase(speed);
	leftBase (speed);
}
task main()
{

	//testtt

	//shoot from front to middle, back tile to top 2 points, across the field?


	//use tbh and code and test all three





	// back shoot one to top == 2 points

	// 1. run the shooter (find the minimum time needed to shoot the flag  if you cant shoot middle from here shoot top from our side and the turn to get the ball
	//shooter (127);
	//wait1Msec(1000);

	//// 1. run the intake (2 points)
	//roller (127);


	// 2. turn 45 degrees (if we do second option then turn 90)


	// 2. stop the shooter


	// 2. hit the wall


	// 2. drive straight to get the ball


	// 2. run the intake


	// 2. move back to hit the wall


	// 2. stop the intake


	// 2. move forward a small distance so the turn does not mess up


	// 2. turn 90 degrees


	// 2. move forward to front red tile




	// front 2 flags +cap  == 5 points +1 point =   6 points /5

	// run the shooter
	shooter (127);

	//drive straight up
	straight_dist (340,127);

	//moveBase (127);
	//wait1Msec(50);

	//brake
	brake();
	wait1Msec(50);


	//drive back out =1 point
	straight_dist (150,-127);

	//will probably need to turn here
	PIDbaseTurn (16, 1, 75);

	//shoot from tile to top flag  = 2 points

	roller(127);
	wait1Msec (1000);
	roller(0);
	shooter(0);


	//drive back out more
	PIDbaseTurn(-5,1,75);
	straight_dist(230,-127);


	//turn 90 degree to  get the ball from the cap
	PIDbaseTurn (90, 1, 70);

	//hit the wall slowly

	straight_dist(75,-127);


	//move up to the cap
	roller(127);
	straight_dist(240,127);


	//try flipping cap if i can here! = 1 point


	straight_dist(75,40);
	brake();
	straight_dist (45,60);

/*
	//run intake

	roller(0);
	//roller (-127);
	//wait1Msec(250);
	//straight_dist (120,75);
	//roller(127);
	//wait1Msec(1000);
	//roller(127);
	//wait1Msec(58);

	//go back to tile
	shooter(127);
	straight_dist(380,-127);
	//hit wall slowly



	//move forward a little
	straight_dist (15, 127);


	//turn the robot 90 degrees OR 45 degrees to hit middle flag
	PIDbaseTurn (-90,1,70);
	//PIDbaseTurn (-45,1,70);

	//move forward if needed
	straight_dist (5,127);
	//shoot the ball
	roller(127);
	wait1Msec(50);


	//hit it maybe slower

	/*
	// flip the cap in skills
	roller (-127);
	wait1Msec(250);
	straight_dist (120,75);
	roller(127);
	wait1Msec(1000);
	roller(127);
	wait1Msec(58);
	*/

	//climb onto platform

}
